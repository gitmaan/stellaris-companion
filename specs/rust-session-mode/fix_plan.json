{
  "feature": "Regex-to-Rust Migration",
  "description": "Migrate regex-based extraction to Rust session operations for accuracy and performance",
  "spec_dir": "specs/rust-session-mode",
  "branch": "ralph/regex-migration",
  "patterns": [
    {
      "id": "P006",
      "learning": "Keep game logic in Python, Rust provides fast primitives only",
      "date": "2026-01-23"
    },
    {
      "id": "P008",
      "learning": "Mixin files have both _rust and _regex methods - regex fallbacks are intentional. Criteria should check that Rust methods exist and are USED, not that regex is completely eliminated",
      "date": "2026-01-24"
    },
    {
      "id": "P009",
      "learning": "session() returns a context manager. Keep a reference! 'ctx=session(path); s=ctx.__enter__()' works. Use RustSession(path) directly for simplest one-liners",
      "date": "2026-01-24"
    },
    {
      "id": "P010",
      "learning": "Entry from iter_section might be string 'none' (deleted entry) - always check isinstance(entry, dict) before accessing",
      "date": "2026-01-24"
    },
    {
      "id": "P011",
      "learning": "Use .get() with defaults, never direct [] access on parsed entries - fields may be missing",
      "date": "2026-01-24"
    },
    {
      "id": "P012",
      "learning": "Fields can be str, int, float, dict, or list - handle type variations with isinstance checks",
      "date": "2026-01-24"
    },
    {
      "id": "P013",
      "learning": "Entry IDs from iter_section are strings, convert to int if needed for comparison",
      "date": "2026-01-24"
    },
    {
      "id": "P014",
      "learning": "Follow MIGRATION_PATTERN.md: 1.BASELINE 2.ANALYZE 3.IMPLEMENT 4.COMPARE 5.BENCHMARK 6.DISPATCH 7.FALLBACK",
      "date": "2026-01-24"
    },
    {
      "id": "P015",
      "learning": "get_entries returns list of dicts with _key field. With projection: {_key, field1, field2...}. Without projection: {_key, _value}. Missing keys silently skipped.",
      "date": "2026-01-24"
    },
    {
      "id": "P016",
      "learning": "contains_kv returns matches dict keyed by 'key=value' strings. Boolean values use 'yes'/'no' strings, numbers compared as strings. Traverses entire parsed tree.",
      "date": "2026-01-24"
    },
    {
      "id": "P017",
      "learning": "_get_active_session() only returns a session when using session() context manager (which sets thread-local). RustSession() directly does NOT set thread-local, so dispatch methods won't see the session. Use 'with rust_session(path):' or 'ctx=session(path); ctx.__enter__()' for tests.",
      "date": "2026-01-24"
    },
    {
      "id": "P018",
      "learning": "Jomini parser collapses duplicate keys into single dict. For Stellaris sections with multiple same-named entries (e.g., relation={} in relations_manager), regex is still needed. Hybrid approach acceptable: use Rust for iteration/lookup, regex for duplicate-key blocks.",
      "date": "2026-01-24"
    }
  ],
  "stories": [
    {
      "id": "MIG-001",
      "title": "Add get_entry operation to serve.rs",
      "priority": 1,
      "description": "Fetch a single entry by section and key ID - avoids iterating entire section",
      "files": ["stellaris-parser/src/commands/serve.rs", "rust_bridge.py"],
      "passes": true,
      "criteria": [
        "RUN: grep -q 'get_entry' stellaris-parser/src/commands/serve.rs (operation exists)",
        "RUN: grep -q 'def get_entry' rust_bridge.py (Python wrapper exists)",
        "RUN: cd stellaris-parser && ~/.cargo/bin/cargo build --release 2>&1 | tail -5 (builds)",
        "RUN: cd stellaris-parser && ~/.cargo/bin/cargo test 2>&1 | grep -q 'test result: ok' (tests pass)",
        "RUN: python3 -c \"from rust_bridge import RustSession; s=RustSession('test_save.sav'); r=s.get_entry('country', '0'); s.close(); print(type(r)); assert isinstance(r, dict)\" (returns dict for valid ID)"
      ],
      "notes": "Implemented 2026-01-24. Returns entry dict if found, None if not found."
    },
    {
      "id": "MIG-002",
      "title": "Add get_entries operation to serve.rs",
      "priority": 1,
      "description": "Batch fetch multiple entries by IDs with optional field projection - key for owned fleet lookup",
      "files": ["stellaris-parser/src/commands/serve.rs", "rust_bridge.py"],
      "passes": true,
      "criteria": [
        "RUN: grep -q 'get_entries' stellaris-parser/src/commands/serve.rs (operation exists)",
        "RUN: grep -q 'def get_entries' rust_bridge.py (Python wrapper exists)",
        "RUN: cd stellaris-parser && ~/.cargo/bin/cargo build --release 2>&1 | tail -5 (builds)",
        "RUN: python3 -c \"from rust_bridge import RustSession; s=RustSession('test_save.sav'); r=s.get_entries('country', ['0','1','2']); s.close(); print(len(r)); assert len(r) >= 1\" (returns multiple entries)",
        "RUN: python3 -c \"from rust_bridge import RustSession; s=RustSession('test_save.sav'); r=s.get_entries('country', ['0'], fields=['name','type']); s.close(); print(r); assert 'name' in str(r) or len(r) > 0\" (field projection works)"
      ],
      "notes": "Implemented 2026-01-24. Returns list of entry dicts with _key field. Supports optional field projection. Missing keys are silently skipped."
    },
    {
      "id": "MIG-003",
      "title": "Add contains_kv operation to serve.rs",
      "priority": 2,
      "description": "Whitespace-insensitive key=value check - fixes contains_tokens limitation for patterns like 'war_in_heaven=yes'",
      "files": ["stellaris-parser/src/commands/serve.rs", "rust_bridge.py"],
      "passes": true,
      "criteria": [
        "RUN: grep -q 'contains_kv' stellaris-parser/src/commands/serve.rs (operation exists)",
        "RUN: grep -q 'def contains_kv' rust_bridge.py (Python wrapper exists)",
        "RUN: cd stellaris-parser && ~/.cargo/bin/cargo build --release 2>&1 | tail -5 (builds)",
        "RUN: python3 -c \"from rust_bridge import RustSession; s=RustSession('test_save.sav'); r=s.contains_kv([('version', '3')]); s.close(); print(r); assert 'matches' in r\" (returns matches dict)"
      ],
      "notes": "Implemented 2026-01-24. Traverses parsed JSON tree for whitespace-insensitive k=v matching. Booleans use 'yes'/'no', numbers compared as strings. Returns matches dict keyed by 'key=value' strings."
    },
    {
      "id": "MIG-004",
      "title": "Optimize _analyze_player_fleets with get_entries",
      "priority": 3,
      "description": "Replace iter_section loop with get_entries for owned fleet IDs - avoid iterating 10K+ fleets",
      "files": ["stellaris_save_extractor/base.py"],
      "passes": true,
      "criteria": [
        "RUN: grep -q 'get_entries.*fleet' stellaris_save_extractor/base.py (uses get_entries for fleets)",
        "RUN: python3 -c \"import time; from save_extractor import SaveExtractor; from rust_bridge import session as rust_session; ctx=rust_session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); p=e._find_player_country_content(e.get_player_empire_id()); fids=e._get_owned_fleet_ids(p) if p else []; start=time.time(); r=e._analyze_player_fleets(fids[:200]); elapsed=time.time()-start; ctx.__exit__(None,None,None); print(f'Time: {elapsed:.3f}s'); assert elapsed < 0.05\" (faster than iter_section approach)"
      ],
      "notes": "Implemented 2026-01-24. Uses get_entries to fetch only owned fleets directly instead of iterating 10K+ fleets. 11x faster than iter_section approach (0.005s vs 0.055s). Criterion self-healed to use session() context manager per P009."
    },
    {
      "id": "MIG-005",
      "title": "Migrate get_diplomacy relations parsing",
      "priority": 4,
      "description": "Replace 80KB-limited regex with Rust session - accuracy critical for large empires",
      "files": ["stellaris_save_extractor/diplomacy.py"],
      "passes": true,
      "criteria": [
        "RUN: grep -q '_get_diplomacy_rust' stellaris_save_extractor/diplomacy.py (Rust method exists)",
        "RUN: grep -q '_get_diplomacy_regex' stellaris_save_extractor/diplomacy.py (fallback exists)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session as rust_session; ctx=rust_session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); r=e.get_diplomacy(); ctx.__exit__(None,None,None); print('relations' in str(r) or 'opinion' in str(r) or len(r) > 0)\" (get_diplomacy works with session context)"
      ],
      "notes": "Implemented 2026-01-24. Hybrid approach: uses Rust iter_section for federation ID lookup, regex for relation entries due to jomini duplicate-key collapse. Criterion self-healed to use session() context manager per P017."
    },
    {
      "id": "MIG-006",
      "title": "Migrate get_military_summary",
      "priority": 5,
      "description": "Fleet and war data extraction using Rust session",
      "files": ["stellaris_save_extractor/military.py"],
      "passes": false,
      "criteria": [
        "RUN: grep -q '_get_military_summary_rust' stellaris_save_extractor/military.py (Rust method exists)",
        "RUN: grep -q '_get_active_session' stellaris_save_extractor/military.py (imports session)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import RustSession; s=RustSession('test_save.sav'); e=SaveExtractor('test_save.sav'); r=e.get_military_summary(); s.close(); print(r); assert isinstance(r, dict)\" (works with session)"
      ],
      "notes": "Follow MIGRATION_PATTERN.md"
    },
    {
      "id": "MIG-007",
      "title": "Migrate get_planets",
      "priority": 6,
      "description": "Planet data with complex nested structures (pops, buildings, districts)",
      "files": ["stellaris_save_extractor/planets.py"],
      "passes": false,
      "criteria": [
        "RUN: grep -q '_get_planets_rust' stellaris_save_extractor/planets.py (Rust method exists)",
        "RUN: grep -q '_get_active_session' stellaris_save_extractor/planets.py (imports session)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import RustSession; s=RustSession('test_save.sav'); e=SaveExtractor('test_save.sav'); r=e.get_planets(); s.close(); print(f'Got {len(r)} planets'); assert len(r) > 0\" (works with session)"
      ],
      "notes": "Follow MIGRATION_PATTERN.md - complex nested structures, test thoroughly"
    },
    {
      "id": "MIG-008",
      "title": "Performance validation - target <2s briefing",
      "priority": 7,
      "description": "Verify full briefing meets target after all migrations",
      "files": [],
      "passes": false,
      "criteria": [
        "RUN: python3 -c \"import time; from save_extractor import SaveExtractor; from rust_bridge import session; start=time.time(); ctx=session('test_save.sav'); sess=ctx.__enter__(); e=SaveExtractor('test_save.sav'); b=e.get_complete_briefing(); ctx.__exit__(None,None,None); elapsed=time.time()-start; print(f'Briefing: {elapsed:.2f}s'); assert elapsed < 3, f'Too slow: {elapsed}s'\" (briefing under 3 seconds)"
      ],
      "notes": "Target is <2s, criteria allows 3s buffer. Current baseline: 3.87s"
    }
  ],
  "discovered": []
}
