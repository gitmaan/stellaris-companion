{
  "feature": "Regex-to-Rust Migration Phase 2",
  "description": "Remove raw gamestate dependency, reduce IPC overhead, add compatibility guardrails",
  "spec_dir": "specs/rust-session-mode",
  "branch": "ralph/regex-migration-p2",
  "patterns": [
    {
      "id": "P006",
      "learning": "Keep game logic in Python, Rust provides fast primitives only",
      "date": "2026-01-23"
    },
    {
      "id": "P008",
      "learning": "Mixin files have both _rust and _regex methods - regex fallbacks are intentional. Criteria should check that Rust methods exist and are USED, not that regex is completely eliminated",
      "date": "2026-01-24"
    },
    {
      "id": "P009",
      "learning": "session() returns a context manager. Keep a reference! 'ctx=session(path); s=ctx.__enter__()' works. Use RustSession(path) directly for simplest one-liners",
      "date": "2026-01-24"
    },
    {
      "id": "P010",
      "learning": "Entry from iter_section might be string 'none' (deleted entry) - always check isinstance(entry, dict) before accessing",
      "date": "2026-01-24"
    },
    {
      "id": "P011",
      "learning": "Use .get() with defaults, never direct [] access on parsed entries - fields may be missing",
      "date": "2026-01-24"
    },
    {
      "id": "P012",
      "learning": "Fields can be str, int, float, dict, or list - handle type variations with isinstance checks",
      "date": "2026-01-24"
    },
    {
      "id": "P013",
      "learning": "Entry IDs from iter_section are strings, convert to int if needed for comparison",
      "date": "2026-01-24"
    },
    {
      "id": "P014",
      "learning": "Follow MIGRATION_PATTERN.md: 1.BASELINE 2.ANALYZE 3.IMPLEMENT 4.COMPARE 5.BENCHMARK 6.DISPATCH 7.FALLBACK",
      "date": "2026-01-24"
    },
    {
      "id": "P015",
      "learning": "get_entries returns list of dicts with _key field. With projection: {_key, field1, field2...}. Without projection: {_key, _value}. Missing keys silently skipped.",
      "date": "2026-01-24"
    },
    {
      "id": "P016",
      "learning": "contains_kv returns matches dict keyed by 'key=value' strings. Boolean values use 'yes'/'no' strings, numbers compared as strings. Traverses entire parsed tree.",
      "date": "2026-01-24"
    },
    {
      "id": "P017",
      "learning": "_get_active_session() only returns a session when using session() context manager (which sets thread-local). RustSession() directly does NOT set thread-local, so dispatch methods won't see the session. Use 'with rust_session(path):' or 'ctx=session(path); ctx.__enter__()' for tests.",
      "date": "2026-01-24"
    },
    {
      "id": "P018",
      "learning": "Jomini parser collapses duplicate keys into single dict. For Stellaris sections with multiple same-named entries (e.g., relation={} in relations_manager, traits= in leaders), regex is still needed OR add Rust op that preserves duplicates.",
      "date": "2026-01-24"
    },
    {
      "id": "P019",
      "learning": "Regex chunk-based parsing can include data from adjacent sections if the chunk size exceeds the actual section size. Rust iter_section respects section boundaries. This can cause regex to return false positives.",
      "date": "2026-01-24"
    },
    {
      "id": "P020",
      "learning": "_extract_section() in base.py uses raw self.gamestate text slicing. Callers should migrate to extract_sections() or iter_section() for session mode.",
      "date": "2026-01-24"
    },
    {
      "id": "P021",
      "learning": "Use session.get_entry(section, key) for O(1) lookup of a single entry by ID, instead of iter_section which scans all entries. Ideal when you already know the specific ID (e.g., federation ID from player country).",
      "date": "2026-01-24"
    }
  ],
  "stories": [
    {
      "id": "MIG-009",
      "title": "Replace _extract_campaign_id with Rust",
      "priority": 1,
      "description": "briefing.py _extract_campaign_id() scans raw gamestate for galaxy= section. Replace with extract_sections(['galaxy']) in session mode.",
      "files": ["stellaris_save_extractor/briefing.py"],
      "passes": true,
      "criteria": [
        "RUN: grep -q '_extract_campaign_id_rust\\|extract_sections.*galaxy' stellaris_save_extractor/briefing.py (Rust-based extraction exists)",
        "RUN: ! grep -q 'self.gamestate.find.*galaxy' stellaris_save_extractor/briefing.py || grep -q '_regex' stellaris_save_extractor/briefing.py (raw gamestate only in fallback)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); b=e.get_complete_briefing(); ctx.__exit__(None,None,None); print(f'campaign_id: {b.get(\\\"campaign_id\\\")}'[:50])\" (briefing works with session)"
      ],
      "notes": "Completed 2026-01-24. Moved nested function to methods: _extract_campaign_id(), _extract_campaign_id_rust(), _extract_campaign_id_regex(). Uses session.extract_sections(['galaxy']) for fast parsed lookup."
    },
    {
      "id": "MIG-010",
      "title": "Remove _find_player_country_content prewarm",
      "priority": 1,
      "description": "briefing.py pre-warms player country content unconditionally. In session mode, use get_entry('country', player_id) instead of raw gamestate slicing.",
      "files": ["stellaris_save_extractor/briefing.py", "stellaris_save_extractor/base.py"],
      "passes": true,
      "criteria": [
        "RUN: ! grep -q '_find_player_country_content' stellaris_save_extractor/briefing.py || grep -B5 '_find_player_country_content' stellaris_save_extractor/briefing.py | grep -q 'not.*session\\|_regex\\|fallback' (prewarm removed or guarded)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); b=e.get_complete_briefing(); ctx.__exit__(None,None,None); print('OK')\" (briefing works without prewarm)"
      ],
      "notes": "Completed 2026-01-24. Added session check guard: 'if not _get_active_session()' before prewarm call. In session mode, methods use _get_player_country_entry() for O(1) lookup instead of raw text cache."
    },
    {
      "id": "MIG-011",
      "title": "Migrate get_galactic_community to Rust",
      "priority": 2,
      "description": "diplomacy.py get_galactic_community() uses _extract_section('galactic_community') which is raw gamestate. Migrate to extract_sections() or iter_section().",
      "files": ["stellaris_save_extractor/diplomacy.py"],
      "passes": true,
      "criteria": [
        "RUN: grep -q '_get_galactic_community_rust' stellaris_save_extractor/diplomacy.py (Rust method exists)",
        "RUN: grep -q '_get_galactic_community_regex' stellaris_save_extractor/diplomacy.py (fallback exists)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); r=e.get_galactic_community(); ctx.__exit__(None,None,None); print(f'GC: {type(r)}'); assert isinstance(r, dict)\" (works with session)"
      ],
      "notes": "Completed 2026-01-24. Uses session.extract_sections(['galactic_community']) for parsed dict access instead of regex. 5x speedup (629ms → 126ms). Output matches baseline exactly."
    },
    {
      "id": "MIG-012",
      "title": "Migrate get_federation_details to Rust",
      "priority": 2,
      "description": "diplomacy.py get_federation_details() uses _extract_section('federation'). Migrate to Rust-backed access using get_entry.",
      "files": ["stellaris_save_extractor/diplomacy.py"],
      "passes": true,
      "criteria": [
        "RUN: grep -q '_get_federation_details_rust' stellaris_save_extractor/diplomacy.py (Rust method exists)",
        "RUN: grep -q '_get_federation_details_regex' stellaris_save_extractor/diplomacy.py (fallback exists)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); r=e.get_federation_details(); ctx.__exit__(None,None,None); print(f'Fed: {type(r)}'); assert isinstance(r, dict)\" (works with session)"
      ],
      "notes": "Completed 2026-01-24. Uses session.get_entry('federation', fed_id) for O(1) lookup. Extracts type/level/cohesion/experience/laws from federation_progression nested dict. Output matches regex baseline."
    },
    {
      "id": "MIG-013",
      "title": "Migrate get_agreements to Rust",
      "priority": 2,
      "description": "diplomacy.py uses _extract_section('agreements'). Migrate to Rust-backed access.",
      "files": ["stellaris_save_extractor/diplomacy.py"],
      "passes": false,
      "criteria": [
        "RUN: grep -q 'extract_sections.*agreements\\|iter_section.*agreement' stellaris_save_extractor/diplomacy.py (Rust-backed access)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); r=e.get_subjects() if hasattr(e, 'get_subjects') else {}; ctx.__exit__(None,None,None); print('OK')\" (works with session)"
      ],
      "notes": "agreements section is used for vassals/subjects."
    },
    {
      "id": "MIG-014",
      "title": "Migrate get_espionage to Rust",
      "priority": 3,
      "description": "diplomacy.py uses _extract_section('espionage_operations'). Migrate to Rust-backed access.",
      "files": ["stellaris_save_extractor/diplomacy.py"],
      "passes": false,
      "criteria": [
        "RUN: grep -q 'extract_sections.*espionage\\|iter_section.*espionage' stellaris_save_extractor/diplomacy.py (Rust-backed access)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); print('OK'); ctx.__exit__(None,None,None)\" (no crash)"
      ],
      "notes": "espionage_operations may not exist in all saves - handle missing gracefully."
    },
    {
      "id": "MIG-015",
      "title": "Add Rust op for duplicate-key sections (leader traits)",
      "priority": 3,
      "description": "Jomini collapses duplicate keys but leader traits need all values. Add get_entry_raw or get_duplicate_values op that preserves repeated keys.",
      "files": ["stellaris-parser/src/commands/serve.rs", "rust_bridge.py", "stellaris_save_extractor/leaders.py"],
      "passes": false,
      "criteria": [
        "RUN: grep -q 'get_duplicate_values\\|get_entry_raw\\|preserve.*duplicate' stellaris-parser/src/commands/serve.rs (Rust op exists)",
        "RUN: grep -q 'get_duplicate_values\\|get_entry_raw' rust_bridge.py (Python wrapper exists)",
        "RUN: cd stellaris-parser && ~/.cargo/bin/cargo build --release 2>&1 | tail -5 (builds)",
        "RUN: python3 -c \"from rust_bridge import RustSession; s=RustSession('test_save.sav'); print('Rust bridge works'); s.close()\" (bridge works)"
      ],
      "notes": "This fixes both accuracy (get all traits) and performance (remove gamestate fallback in leaders.py). Could return {key: [val1, val2, ...]} for specified duplicate-key fields."
    },
    {
      "id": "MIG-016",
      "title": "Remove leader traits gamestate fallback",
      "priority": 4,
      "description": "Once MIG-015 provides duplicate-key support, update leaders.py to use it instead of raw gamestate regex for traits.",
      "files": ["stellaris_save_extractor/leaders.py"],
      "passes": false,
      "criteria": [
        "RUN: grep -q '_get_leaders_rust' stellaris_save_extractor/leaders.py (Rust method exists)",
        "RUN: ! grep -q 'self.gamestate' stellaris_save_extractor/leaders.py || grep -B3 'self.gamestate' stellaris_save_extractor/leaders.py | grep -q '_regex\\|fallback\\|debug' (gamestate only in fallback)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); r=e.get_leaders(); ctx.__exit__(None,None,None); leaders=r.get('leaders',[]); has_traits=any(l.get('traits') for l in leaders[:5]); print(f'Leaders with traits: {has_traits}'); assert has_traits\" (traits extracted via Rust)"
      ],
      "notes": "Depends on MIG-015. This removes the hybrid approach documented in P018."
    },
    {
      "id": "MIG-017",
      "title": "Add multi-op request to serve.rs",
      "priority": 4,
      "description": "Reduce IPC overhead by allowing multiple operations in one request. One send → many results instead of 3590 round-trips.",
      "files": ["stellaris-parser/src/commands/serve.rs", "rust_bridge.py"],
      "passes": false,
      "criteria": [
        "RUN: grep -q 'multi_op\\|batch_ops\\|MultiRequest' stellaris-parser/src/commands/serve.rs (multi-op support exists)",
        "RUN: grep -q 'multi_op\\|batch_ops\\|send_batch' rust_bridge.py (Python wrapper exists)",
        "RUN: cd stellaris-parser && ~/.cargo/bin/cargo build --release 2>&1 | tail -5 (builds)",
        "RUN: python3 -c \"from rust_bridge import RustSession; s=RustSession('test_save.sav'); print('Multi-op test'); s.close()\" (bridge works)"
      ],
      "notes": "Request format: {op: 'multi', ops: [{op: 'get_entry', ...}, {op: 'count_keys', ...}]}. Response: {results: [...]}."
    },
    {
      "id": "MIG-018",
      "title": "Switch to orjson for faster JSON parsing",
      "priority": 5,
      "description": "Replace json.loads/dumps with orjson in rust_bridge.py for ~80% faster JSON parsing.",
      "files": ["rust_bridge.py", "requirements.txt"],
      "passes": false,
      "criteria": [
        "RUN: grep -q 'orjson' rust_bridge.py (orjson imported)",
        "RUN: grep -q 'orjson' requirements.txt || grep -q 'orjson' pyproject.toml (dependency added)",
        "RUN: python3 -c \"import orjson; print('orjson available')\" (orjson installed)",
        "RUN: python3 -c \"from rust_bridge import RustSession; s=RustSession('test_save.sav'); r=s.get_entry('country','0'); s.close(); print('OK')\" (bridge works with orjson)"
      ],
      "notes": "orjson.loads() returns bytes, orjson.dumps() returns bytes. May need .decode() in places."
    },
    {
      "id": "MIG-019",
      "title": "Performance validation - target <2s briefing",
      "priority": 6,
      "description": "Verify full briefing meets <2s target after all optimizations.",
      "files": [],
      "passes": false,
      "criteria": [
        "RUN: python3 -c \"import time; from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); times=[]; exec('for _ in range(3):\\n  start=time.time()\\n  b=e.get_complete_briefing()\\n  times.append(time.time()-start)'); ctx.__exit__(None,None,None); avg=sum(times)/len(times); print(f'Avg: {avg:.2f}s'); assert avg < 2.5, f'Too slow: {avg}s'\" (briefing under 2.5 seconds)"
      ],
      "notes": "Target is <2s, criterion allows 2.5s buffer. Current baseline: 2.83s."
    },
    {
      "id": "MIG-020",
      "title": "Add save corpus regression test",
      "priority": 6,
      "description": "Create test suite with diverse saves: base game, DLC mixes, popular mods, early/mid/late game stages.",
      "files": ["tests/test_save_corpus.py"],
      "passes": false,
      "criteria": [
        "RUN: test -f tests/test_save_corpus.py (test file exists)",
        "RUN: grep -q 'def test_' tests/test_save_corpus.py (has test functions)",
        "RUN: grep -q 'base_game\\|dlc\\|mod\\|early\\|late' tests/test_save_corpus.py (tests different save types)"
      ],
      "notes": "Tests should verify: no crashes, reasonable output, consistent results between Rust and regex modes. Can use test_save.sav as baseline, add more saves over time."
    },
    {
      "id": "MIG-021",
      "title": "Add diagnostics export mode",
      "priority": 7,
      "description": "Allow users to export errors, versions, and which extractors fell back without uploading saves.",
      "files": ["stellaris_save_extractor/diagnostics.py"],
      "passes": false,
      "criteria": [
        "RUN: test -f stellaris_save_extractor/diagnostics.py (diagnostics module exists)",
        "RUN: grep -q 'export_diagnostics\\|get_diagnostics' stellaris_save_extractor/diagnostics.py (export function exists)",
        "RUN: grep -q 'fallback\\|error\\|version' stellaris_save_extractor/diagnostics.py (captures relevant info)"
      ],
      "notes": "Should capture: Python version, Rust parser version, which extractors used fallback, any errors/warnings, timing breakdown. No save data."
    }
  ],
  "discovered": []
}
