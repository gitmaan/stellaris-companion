{
  "feature": "Regex-to-Rust Migration Phase 2",
  "description": "Remove raw gamestate dependency, reduce IPC overhead, add compatibility guardrails",
  "spec_dir": "specs/rust-session-mode",
  "branch": "ralph/regex-migration-p2",
  "patterns": [
    {
      "id": "P006",
      "learning": "Keep game logic in Python, Rust provides fast primitives only",
      "date": "2026-01-23"
    },
    {
      "id": "P008",
      "learning": "Mixin files have both _rust and _regex methods - regex fallbacks are intentional. Criteria should check that Rust methods exist and are USED, not that regex is completely eliminated",
      "date": "2026-01-24"
    },
    {
      "id": "P009",
      "learning": "session() returns a context manager. Keep a reference! 'ctx=session(path); s=ctx.__enter__()' works. Use RustSession(path) directly for simplest one-liners",
      "date": "2026-01-24"
    },
    {
      "id": "P010",
      "learning": "Entry from iter_section might be string 'none' (deleted entry) - always check isinstance(entry, dict) before accessing",
      "date": "2026-01-24"
    },
    {
      "id": "P011",
      "learning": "Use .get() with defaults, never direct [] access on parsed entries - fields may be missing",
      "date": "2026-01-24"
    },
    {
      "id": "P012",
      "learning": "Fields can be str, int, float, dict, or list - handle type variations with isinstance checks",
      "date": "2026-01-24"
    },
    {
      "id": "P013",
      "learning": "Entry IDs from iter_section are strings, convert to int if needed for comparison",
      "date": "2026-01-24"
    },
    {
      "id": "P014",
      "learning": "Follow MIGRATION_PATTERN.md: 1.BASELINE 2.ANALYZE 3.IMPLEMENT 4.COMPARE 5.BENCHMARK 6.DISPATCH 7.FALLBACK",
      "date": "2026-01-24"
    },
    {
      "id": "P015",
      "learning": "get_entries returns list of dicts with _key field. With projection: {_key, field1, field2...}. Without projection: {_key, _value}. Missing keys silently skipped.",
      "date": "2026-01-24"
    },
    {
      "id": "P016",
      "learning": "contains_kv returns matches dict keyed by 'key=value' strings. Boolean values use 'yes'/'no' strings, numbers compared as strings. Traverses entire parsed tree.",
      "date": "2026-01-24"
    },
    {
      "id": "P017",
      "learning": "_get_active_session() only returns a session when using session() context manager (which sets thread-local). RustSession() directly does NOT set thread-local, so dispatch methods won't see the session. Use 'with rust_session(path):' or 'ctx=session(path); ctx.__enter__()' for tests.",
      "date": "2026-01-24"
    },
    {
      "id": "P018",
      "learning": "Jomini parser collapses duplicate keys into single dict. For Stellaris sections with multiple same-named entries (e.g., relation={} in relations_manager, traits= in leaders), regex is still needed OR add Rust op that preserves duplicates.",
      "date": "2026-01-24"
    },
    {
      "id": "P019",
      "learning": "Regex chunk-based parsing can include data from adjacent sections if the chunk size exceeds the actual section size. Rust iter_section respects section boundaries. This can cause regex to return false positives.",
      "date": "2026-01-24"
    },
    {
      "id": "P020",
      "learning": "_extract_section() in base.py uses raw self.gamestate text slicing. Callers should migrate to extract_sections() or iter_section() for session mode.",
      "date": "2026-01-24"
    },
    {
      "id": "P021",
      "learning": "Use session.get_entry(section, key) for O(1) lookup of a single entry by ID, instead of iter_section which scans all entries. Ideal when you already know the specific ID (e.g., federation ID from player country).",
      "date": "2026-01-24"
    },
    {
      "id": "P022",
      "learning": "Regex re.search finds first match which may come from nested structures (e.g., log entries) rather than parent-level fields. Rust parsed dict access correctly reads the parent-level field. This can cause regex to return wrong values from nested data.",
      "date": "2026-01-24"
    },
    {
      "id": "P023",
      "learning": "get_duplicate_values(section, key, field) extracts ALL values for a field with duplicate keys by scanning raw bytes. Use for traits, technologies, species traits, etc. Returns list of strings. Entry must exist for values to be found.",
      "date": "2026-01-24"
    },
    {
      "id": "P024",
      "learning": "iter_section and other session methods (get_duplicate_values, get_entry, etc.) cannot be interleaved - they share the same stdin/stdout pipe. Use two-phase approach: (1) collect data during iteration, (2) make additional calls after iteration completes.",
      "date": "2026-01-24"
    },
    {
      "id": "P025",
      "learning": "batch_ops() sends multiple ops in one request: {op: 'multi', ops: [...]}. Returns list of results in same order. Use for many small queries (get_entry, count_keys) to avoid IPC round-trip latency. Does NOT support iter_section (streaming) or close.",
      "date": "2026-01-24"
    },
    {
      "id": "P026",
      "learning": "orjson.dumps() returns bytes (not str), orjson.loads() accepts both bytes and str. orjson raises ValueError on decode errors (not JSONDecodeError). Use _json_loads/_json_dumps wrappers from rust_bridge for consistent interface. Check _ORJSON_AVAILABLE for feature detection.",
      "date": "2026-01-24"
    },
    {
      "id": "P027",
      "learning": "batch_ops with multiple get_duplicate_values targeting the SAME section now caches section offset in Rust - first call finds section, subsequent calls skip 84MB scan. For N leader traits this gives ~25x speedup. Use batch_ops for multiple get_duplicate_values calls.",
      "date": "2026-01-24"
    }
  ],
  "stories": [
    {
      "id": "MIG-009",
      "title": "Replace _extract_campaign_id with Rust",
      "priority": 1,
      "description": "briefing.py _extract_campaign_id() scans raw gamestate for galaxy= section. Replace with extract_sections(['galaxy']) in session mode.",
      "files": ["stellaris_save_extractor/briefing.py"],
      "passes": true,
      "criteria": [
        "RUN: grep -q '_extract_campaign_id_rust\\|extract_sections.*galaxy' stellaris_save_extractor/briefing.py (Rust-based extraction exists)",
        "RUN: ! grep -q 'self.gamestate.find.*galaxy' stellaris_save_extractor/briefing.py || grep -q '_regex' stellaris_save_extractor/briefing.py (raw gamestate only in fallback)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); b=e.get_complete_briefing(); ctx.__exit__(None,None,None); print(f'campaign_id: {b.get(\\\"campaign_id\\\")}'[:50])\" (briefing works with session)"
      ],
      "notes": "Completed 2026-01-24. Moved nested function to methods: _extract_campaign_id(), _extract_campaign_id_rust(), _extract_campaign_id_regex(). Uses session.extract_sections(['galaxy']) for fast parsed lookup."
    },
    {
      "id": "MIG-010",
      "title": "Remove _find_player_country_content prewarm",
      "priority": 1,
      "description": "briefing.py pre-warms player country content unconditionally. In session mode, use get_entry('country', player_id) instead of raw gamestate slicing.",
      "files": ["stellaris_save_extractor/briefing.py", "stellaris_save_extractor/base.py"],
      "passes": true,
      "criteria": [
        "RUN: ! grep -q '_find_player_country_content' stellaris_save_extractor/briefing.py || grep -B5 '_find_player_country_content' stellaris_save_extractor/briefing.py | grep -q 'not.*session\\|_regex\\|fallback' (prewarm removed or guarded)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); b=e.get_complete_briefing(); ctx.__exit__(None,None,None); print('OK')\" (briefing works without prewarm)"
      ],
      "notes": "Completed 2026-01-24. Added session check guard: 'if not _get_active_session()' before prewarm call. In session mode, methods use _get_player_country_entry() for O(1) lookup instead of raw text cache."
    },
    {
      "id": "MIG-011",
      "title": "Migrate get_galactic_community to Rust",
      "priority": 2,
      "description": "diplomacy.py get_galactic_community() uses _extract_section('galactic_community') which is raw gamestate. Migrate to extract_sections() or iter_section().",
      "files": ["stellaris_save_extractor/diplomacy.py"],
      "passes": true,
      "criteria": [
        "RUN: grep -q '_get_galactic_community_rust' stellaris_save_extractor/diplomacy.py (Rust method exists)",
        "RUN: grep -q '_get_galactic_community_regex' stellaris_save_extractor/diplomacy.py (fallback exists)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); r=e.get_galactic_community(); ctx.__exit__(None,None,None); print(f'GC: {type(r)}'); assert isinstance(r, dict)\" (works with session)"
      ],
      "notes": "Completed 2026-01-24. Uses session.extract_sections(['galactic_community']) for parsed dict access instead of regex. 5x speedup (629ms → 126ms). Output matches baseline exactly."
    },
    {
      "id": "MIG-012",
      "title": "Migrate get_federation_details to Rust",
      "priority": 2,
      "description": "diplomacy.py get_federation_details() uses _extract_section('federation'). Migrate to Rust-backed access using get_entry.",
      "files": ["stellaris_save_extractor/diplomacy.py"],
      "passes": true,
      "criteria": [
        "RUN: grep -q '_get_federation_details_rust' stellaris_save_extractor/diplomacy.py (Rust method exists)",
        "RUN: grep -q '_get_federation_details_regex' stellaris_save_extractor/diplomacy.py (fallback exists)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); r=e.get_federation_details(); ctx.__exit__(None,None,None); print(f'Fed: {type(r)}'); assert isinstance(r, dict)\" (works with session)"
      ],
      "notes": "Completed 2026-01-24. Uses session.get_entry('federation', fed_id) for O(1) lookup. Extracts type/level/cohesion/experience/laws from federation_progression nested dict. Output matches regex baseline."
    },
    {
      "id": "MIG-013",
      "title": "Migrate get_agreements to Rust",
      "priority": 2,
      "description": "diplomacy.py uses _extract_section('agreements'). Migrate to Rust-backed access.",
      "files": ["stellaris_save_extractor/diplomacy.py"],
      "passes": true,
      "criteria": [
        "RUN: grep -q 'extract_sections.*agreements\\|iter_section.*agreement' stellaris_save_extractor/diplomacy.py (Rust-backed access)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); r=e.get_subjects() if hasattr(e, 'get_subjects') else {}; ctx.__exit__(None,None,None); print('OK')\" (works with session)"
      ],
      "notes": "Completed 2026-01-24. Uses session.extract_sections(['agreements']) for parsed dict access. Dispatches to _get_subjects_rust() when session active. 3300x speedup (0.87s → 0.0003s). Output matches regex baseline exactly."
    },
    {
      "id": "MIG-014",
      "title": "Migrate get_espionage to Rust",
      "priority": 3,
      "description": "diplomacy.py uses _extract_section('espionage_operations'). Migrate to Rust-backed access.",
      "files": ["stellaris_save_extractor/diplomacy.py"],
      "passes": true,
      "criteria": [
        "RUN: grep -q 'extract_sections.*espionage\\|iter_section.*espionage' stellaris_save_extractor/diplomacy.py (Rust-backed access)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); print('OK'); ctx.__exit__(None,None,None)\" (no crash)"
      ],
      "notes": "Completed 2026-01-24. Uses session.extract_sections(['espionage_operations']) for parsed dict access. ACCURACY FIX: Rust version correctly extracts operation-level 'info' field; regex version incorrectly matched log entry 'info' values due to greedy regex matching first occurrence."
    },
    {
      "id": "MIG-015",
      "title": "Add Rust op for duplicate-key sections (leader traits)",
      "priority": 3,
      "description": "Jomini collapses duplicate keys but leader traits need all values. Add get_entry_raw or get_duplicate_values op that preserves repeated keys.",
      "files": ["stellaris-parser/src/commands/serve.rs", "rust_bridge.py", "stellaris_save_extractor/leaders.py"],
      "passes": true,
      "criteria": [
        "RUN: grep -q 'get_duplicate_values\\|get_entry_raw\\|preserve.*duplicate' stellaris-parser/src/commands/serve.rs (Rust op exists)",
        "RUN: grep -q 'get_duplicate_values\\|get_entry_raw' rust_bridge.py (Python wrapper exists)",
        "RUN: cd stellaris-parser && ~/.cargo/bin/cargo build --release 2>&1 | tail -5 (builds)",
        "RUN: python3 -c \"from rust_bridge import RustSession; s=RustSession('test_save.sav'); print('Rust bridge works'); s.close()\" (bridge works)"
      ],
      "notes": "Completed 2026-01-24. Added get_duplicate_values Rust op that scans raw bytes to extract all values for fields with duplicate keys (e.g., traits= appearing multiple times). Python wrapper returns list of strings. Tested with leader traits - correctly extracts all traits where regex was needed before."
    },
    {
      "id": "MIG-016",
      "title": "Remove leader traits gamestate fallback",
      "priority": 4,
      "description": "Once MIG-015 provides duplicate-key support, update leaders.py to use it instead of raw gamestate regex for traits.",
      "files": ["stellaris_save_extractor/leaders.py"],
      "passes": true,
      "criteria": [
        "RUN: grep -q '_get_leaders_rust' stellaris_save_extractor/leaders.py (Rust method exists)",
        "RUN: ! grep -q 'self.gamestate' stellaris_save_extractor/leaders.py || grep -B3 'self.gamestate' stellaris_save_extractor/leaders.py | grep -q '_regex\\|fallback\\|debug' (gamestate only in fallback)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); r=e.get_leaders(); ctx.__exit__(None,None,None); leaders=r.get('leaders',[]); has_traits=any(l.get('traits') for l in leaders[:5]); print(f'Leaders with traits: {has_traits}'); assert has_traits\" (traits extracted via Rust)"
      ],
      "notes": "Completed 2026-01-24. Updated _get_leaders_rust() to use session.iter_section() and session.get_duplicate_values() for traits. Uses two-phase approach because iter_section and get_duplicate_values cannot be interleaved (same pipe). Removed dead code (_get_leader_blocks_for_traits, _extract_leader_traits_from_block). Output matches baseline exactly (28 leaders, all traits correct). Note: Rust version is slightly slower (~1.3s vs ~0.7s regex) due to 28 individual get_duplicate_values calls, but provides better accuracy (no truncation risk)."
    },
    {
      "id": "MIG-017",
      "title": "Add multi-op request to serve.rs",
      "priority": 4,
      "description": "Reduce IPC overhead by allowing multiple operations in one request. One send → many results instead of 3590 round-trips.",
      "files": ["stellaris-parser/src/commands/serve.rs", "rust_bridge.py"],
      "passes": true,
      "criteria": [
        "RUN: grep -q 'multi_op\\|batch_ops\\|MultiRequest' stellaris-parser/src/commands/serve.rs (multi-op support exists)",
        "RUN: grep -q 'multi_op\\|batch_ops\\|send_batch' rust_bridge.py (Python wrapper exists)",
        "RUN: cd stellaris-parser && ~/.cargo/bin/cargo build --release 2>&1 | tail -5 (builds)",
        "RUN: python3 -c \"from rust_bridge import RustSession; s=RustSession('test_save.sav'); print('Multi-op test'); s.close()\" (bridge works)"
      ],
      "notes": "Completed 2026-01-24. Added Multi request type to serve.rs with MultiOp enum supporting all non-streaming ops. Python wrapper batch_ops() sends {op: 'multi', ops: [...]} and returns results list. Enables N operations in one IPC round-trip."
    },
    {
      "id": "MIG-018",
      "title": "Switch to orjson for faster JSON parsing",
      "priority": 5,
      "description": "Replace json.loads/dumps with orjson in rust_bridge.py for ~80% faster JSON parsing.",
      "files": ["rust_bridge.py", "requirements.txt"],
      "passes": true,
      "criteria": [
        "RUN: grep -q 'orjson' rust_bridge.py (orjson imported)",
        "RUN: grep -q 'orjson' requirements.txt || grep -q 'orjson' pyproject.toml (dependency added)",
        "RUN: python3 -c \"import orjson; print('orjson available')\" (orjson installed)",
        "RUN: python3 -c \"from rust_bridge import RustSession; s=RustSession('test_save.sav'); r=s.get_entry('country','0'); s.close(); print('OK')\" (bridge works with orjson)"
      ],
      "notes": "Completed 2026-01-24. orjson.dumps() returns bytes (no encode needed). orjson.loads() accepts both bytes and str. Wrapped with _json_loads/_json_dumps helpers that fallback to stdlib json if orjson unavailable. orjson raises ValueError on decode errors (not JSONDecodeError). _ORJSON_AVAILABLE flag exposed for testing."
    },
    {
      "id": "MIG-019",
      "title": "Performance validation - target <2s briefing",
      "priority": 6,
      "description": "Verify full briefing meets <2s target after all optimizations.",
      "files": [],
      "passes": true,
      "criteria": [
        "RUN: python3 -c \"import time; from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); times=[]; exec('for _ in range(3):\\n  start=time.time()\\n  b=e.get_complete_briefing()\\n  times.append(time.time()-start)'); ctx.__exit__(None,None,None); avg=sum(times)/len(times); print(f'Avg: {avg:.2f}s'); assert avg < 2.5, f'Too slow: {avg}s'\" (briefing under 2.5 seconds)"
      ],
      "notes": "Completed 2026-01-24. Achieved 1.53s average (target was <2.5s). Key optimization: added section offset caching in Rust batch_ops for get_duplicate_values, reducing N round-trips and repeated 84MB string scans. Updated _get_leaders_rust to use batch_ops for trait extraction (P025). Speedup: get_leaders went from ~0.9s to ~0.04s after warmup."
    },
    {
      "id": "MIG-020",
      "title": "Add save corpus regression test",
      "priority": 6,
      "description": "Create test suite with diverse saves: base game, DLC mixes, popular mods, early/mid/late game stages.",
      "files": ["tests/test_save_corpus.py"],
      "passes": true,
      "criteria": [
        "RUN: test -f tests/test_save_corpus.py (test file exists)",
        "RUN: grep -q 'def test_' tests/test_save_corpus.py (has test functions)",
        "RUN: grep -q 'base_game\\|dlc\\|mod\\|early\\|late' tests/test_save_corpus.py (tests different save types)"
      ],
      "notes": "Completed 2026-01-24. Comprehensive test suite (473 lines) with: basic functionality tests, save type coverage, Rust/regex consistency tests, performance regression tests, data quality tests. Uses test_save.sav as baseline, structured for easy corpus expansion."
    },
    {
      "id": "MIG-021",
      "title": "Add diagnostics export mode",
      "priority": 7,
      "description": "Allow users to export errors, versions, and which extractors fell back without uploading saves.",
      "files": ["stellaris_save_extractor/diagnostics.py"],
      "passes": true,
      "criteria": [
        "RUN: test -f stellaris_save_extractor/diagnostics.py (diagnostics module exists)",
        "RUN: grep -q 'export_diagnostics\\|get_diagnostics' stellaris_save_extractor/diagnostics.py (export function exists)",
        "RUN: grep -q 'fallback\\|error\\|version' stellaris_save_extractor/diagnostics.py (captures relevant info)"
      ],
      "notes": "Completed 2026-01-24. Created diagnostics.py module with: DiagnosticsCollector class (thread-local), get_diagnostics() for snapshot, export_diagnostics() for JSON export, timing/fallback/error recording, version detection (Python, Rust parser, orjson). Includes decorators @timed_extractor and @record_fallback_on_exception for easy instrumentation. No save data included in exports."
    },
    {
      "id": "MIG-022",
      "title": "Migrate get_pop_statistics to Rust",
      "priority": 8,
      "description": "economy.py get_pop_statistics() uses 50MB chunk slicing with re.finditer. Replace with iter_section('pop_groups') for memory efficiency and speed.",
      "files": ["stellaris_save_extractor/economy.py"],
      "passes": true,
      "criteria": [
        "RUN: grep -q '_get_pop_statistics_rust' stellaris_save_extractor/economy.py (Rust method exists)",
        "RUN: grep -q '_get_pop_statistics_regex' stellaris_save_extractor/economy.py (fallback exists)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); r=e.get_pop_statistics(); ctx.__exit__(None,None,None); print(f'Pops: {r.get(\\\"total_pops\\\", 0)}'); assert isinstance(r, dict)\" (works with session)"
      ],
      "notes": "Completed 2026-01-24. Uses iter_section('pop_groups') (not 'pop' as originally noted - pop_groups is the actual section with aggregated pop data). 4.4x speedup (2.34s → 0.53s). Output matches regex baseline exactly: 171724 total pops, all species/job categories match, happiness_avg 75.5. Replaces 50MB chunk slicing with streaming iteration."
    },
    {
      "id": "MIG-023",
      "title": "Migrate _get_country_names_map to Rust",
      "priority": 8,
      "description": "base.py _get_country_names_map_regex() is a hot path resolving 300+ country names. Use iter_section('country') with batch name extraction.",
      "files": ["stellaris_save_extractor/base.py"],
      "passes": true,
      "criteria": [
        "RUN: grep -q '_get_country_names_map_rust' stellaris_save_extractor/base.py (Rust method exists)",
        "RUN: grep -q '_get_country_names_map_regex' stellaris_save_extractor/base.py (fallback exists)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); r=e._get_country_names_map(); ctx.__exit__(None,None,None); print(f'Countries: {len(r)}'); assert len(r) > 0\" (works with session)"
      ],
      "notes": "Already implemented. Uses iter_section_entries() which dispatches to session via _get_active_session(). Resolves template names with _resolve_template_name_from_rust(). 1.3x speedup (0.45s vs 0.57s). 57 countries extracted correctly."
    },
    {
      "id": "MIG-024",
      "title": "Migrate get_fleet_composition to Rust",
      "priority": 9,
      "description": "military.py _get_fleet_composition_regex() has triple nested loops with small snippet slicing. Use iter_section for ships/designs.",
      "files": ["stellaris_save_extractor/military.py"],
      "passes": true,
      "criteria": [
        "RUN: grep -q '_get_fleet_composition_rust' stellaris_save_extractor/military.py (Rust method exists)",
        "RUN: grep -q '_get_fleet_composition_regex' stellaris_save_extractor/military.py (fallback exists)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); r=e.get_fleet_composition(); ctx.__exit__(None,None,None); print(f'Fleets: {len(r.get(\\\"fleets\\\", []))}'); assert isinstance(r, dict)\" (works with session)"
      ],
      "notes": "Already implemented. Uses iter_section for ship_design, ships, and fleet sections. Builds design_id→ship_size and ship_id→design_id mappings, then aggregates ship classes per fleet. Returns 10 fleets with correct composition data."
    },
    {
      "id": "MIG-025",
      "title": "Migrate get_diplomacy core methods to Rust",
      "priority": 9,
      "description": "diplomacy.py has 75 regex calls across multiple methods. Migrate get_relations, get_treaties, get_claims to use iter_section.",
      "files": ["stellaris_save_extractor/diplomacy.py"],
      "passes": false,
      "criteria": [
        "RUN: grep -c 're\\.search\\|re\\.findall\\|re\\.finditer' stellaris_save_extractor/diplomacy.py | awk '{if ($1 < 50) exit 0; else exit 1}' (regex count reduced)",
        "RUN: grep -q 'iter_section.*relation\\|iter_section.*diplomacy' stellaris_save_extractor/diplomacy.py (uses iter_section)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); r=e.get_diplomacy(); ctx.__exit__(None,None,None); print('OK'); assert isinstance(r, dict)\" (works with session)"
      ],
      "notes": "Large file with many regex calls. Focus on highest-impact methods first. Relations data has duplicate keys (relation={}) - may need get_duplicate_values (P023)."
    },
    {
      "id": "MIG-026",
      "title": "Migrate get_budget_breakdown to Rust",
      "priority": 10,
      "description": "economy.py get_budget_breakdown() uses recursive brace matching. Replace with extract_sections for parsed dict access.",
      "files": ["stellaris_save_extractor/economy.py"],
      "passes": true,
      "criteria": [
        "RUN: grep -q '_get_budget_breakdown_rust' stellaris_save_extractor/economy.py (Rust method exists)",
        "RUN: grep -q '_get_budget_breakdown_regex' stellaris_save_extractor/economy.py (fallback exists)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); r=e.get_budget_breakdown(); ctx.__exit__(None,None,None); print(f'Budget: {type(r)}'); assert isinstance(r, dict)\" (works with session)"
      ],
      "notes": "Completed 2026-01-25. Uses session.get_entry('country', player_id) for direct dict access to budget.current_month.income/expenses. 5.4x speedup (0.686s → 0.127s). Output matches regex baseline exactly: 32 income sources, 47 expense sources, all resource nets match."
    },
    {
      "id": "MIG-027",
      "title": "Migrate get_planets to Rust",
      "priority": 10,
      "description": "planets.py has 36 regex calls. _get_planets_regex uses 20MB chunk slicing. Migrate remaining methods to iter_section('planets').",
      "files": ["stellaris_save_extractor/planets.py"],
      "passes": false,
      "criteria": [
        "RUN: grep -c 're\\.search\\|re\\.findall\\|re\\.finditer' stellaris_save_extractor/planets.py | awk '{if ($1 < 20) exit 0; else exit 1}' (regex count reduced by >40%)",
        "RUN: grep -q '_get_planets_rust' stellaris_save_extractor/planets.py (Rust method exists)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); r=e.get_planets(); ctx.__exit__(None,None,None); print(f'Planets: {len(r.get(\\\"colonies\\\", []))}'); assert isinstance(r, dict)\" (works with session)"
      ],
      "notes": "planets.py already has some Rust usage. Focus on _get_planets_regex (20MB chunk), get_archaeology, _get_population_by_planet_regex."
    },
    {
      "id": "MIG-028",
      "title": "Migrate get_player_status to Rust",
      "priority": 10,
      "description": "player.py has 32 regex calls with only 4 Rust usages. Core player data is frequently accessed - migrate main extraction methods.",
      "files": ["stellaris_save_extractor/player.py"],
      "passes": false,
      "criteria": [
        "RUN: grep -c 're\\.search\\|re\\.findall\\|re\\.finditer' stellaris_save_extractor/player.py | awk '{if ($1 < 20) exit 0; else exit 1}' (regex count reduced by >35%)",
        "RUN: grep -q 'iter_section\\|get_entry' stellaris_save_extractor/player.py (uses Rust session ops)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); r=e.get_player_status(); ctx.__exit__(None,None,None); print(f'Player: {r.get(\\\"empire_name\\\", \\\"unknown\\\")}'); assert isinstance(r, dict)\" (works with session)"
      ],
      "notes": "Player status is called on every save load. Uses _get_player_country_entry() which is already Rust-backed - extend to other player.py methods."
    },
    {
      "id": "MIG-029",
      "title": "Migrate get_technology to Rust",
      "priority": 11,
      "description": "technology.py has 18 regex calls extracting tech trees. Use iter_section for tech data.",
      "files": ["stellaris_save_extractor/technology.py"],
      "passes": false,
      "criteria": [
        "RUN: grep -c 're\\.search\\|re\\.findall\\|re\\.finditer' stellaris_save_extractor/technology.py | awk '{if ($1 < 12) exit 0; else exit 1}' (regex count reduced by >30%)",
        "RUN: grep -q '_get_technology_rust\\|iter_section.*tech' stellaris_save_extractor/technology.py (Rust method exists)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); r=e.get_technology(); ctx.__exit__(None,None,None); print(f'Techs: {len(r.get(\\\"researched\\\", []))}'); assert isinstance(r, dict)\" (works with session)"
      ],
      "notes": "Tech data includes researched list, in_progress, and available options. May have duplicate keys for tech_status entries."
    },
    {
      "id": "MIG-030",
      "title": "Migrate get_crisis_status to Rust",
      "priority": 11,
      "description": "endgame.py has 18 regex calls for crisis/endgame detection. Migrate to Rust for accuracy in late-game state detection.",
      "files": ["stellaris_save_extractor/endgame.py"],
      "passes": false,
      "criteria": [
        "RUN: grep -c 're\\.search\\|re\\.findall\\|re\\.finditer' stellaris_save_extractor/endgame.py | awk '{if ($1 < 10) exit 0; else exit 1}' (regex count reduced by >40%)",
        "RUN: grep -q 'iter_section\\|extract_sections\\|get_entry' stellaris_save_extractor/endgame.py (uses Rust session ops)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); r=e.get_crisis_status(); ctx.__exit__(None,None,None); print(f'Crisis: {type(r)}'); assert isinstance(r, dict)\" (works with session)"
      ],
      "notes": "Crisis detection affects Chronicle narratives. Regex may miss nested crisis state. Already has 11 Rust usages - extend coverage."
    },
    {
      "id": "MIG-031",
      "title": "Migrate get_armies to Rust",
      "priority": 12,
      "description": "armies.py has 11 regex calls for ground forces extraction. Migrate to iter_section('army') for accurate army counts.",
      "files": ["stellaris_save_extractor/armies.py"],
      "passes": false,
      "criteria": [
        "RUN: grep -c 're\\.search\\|re\\.findall\\|re\\.finditer' stellaris_save_extractor/armies.py | awk '{if ($1 < 6) exit 0; else exit 1}' (regex count reduced by >45%)",
        "RUN: grep -q 'iter_section\\|extract_sections' stellaris_save_extractor/armies.py (uses Rust session ops)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); r=e.get_armies(); ctx.__exit__(None,None,None); print(f'Armies: {type(r)}'); assert isinstance(r, dict)\" (works with session)"
      ],
      "notes": "Army data for invasion planning. Regex snippet slicing may truncate large army lists."
    },
    {
      "id": "MIG-032",
      "title": "Migrate get_special_projects to Rust",
      "priority": 12,
      "description": "projects.py has 10 regex calls for megaprojects and special projects. Migrate to Rust for complete project state.",
      "files": ["stellaris_save_extractor/projects.py"],
      "passes": false,
      "criteria": [
        "RUN: grep -c 're\\.search\\|re\\.findall\\|re\\.finditer' stellaris_save_extractor/projects.py | awk '{if ($1 < 5) exit 0; else exit 1}' (regex count reduced by >50%)",
        "RUN: grep -q 'iter_section\\|extract_sections' stellaris_save_extractor/projects.py (uses Rust session ops)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); r=e.get_special_projects() if hasattr(e, 'get_special_projects') else {}; ctx.__exit__(None,None,None); print('OK')\" (works with session)"
      ],
      "notes": "Special projects include archaeological sites, precursor chains. Accurate state tracking for Chronicle."
    },
    {
      "id": "MIG-033",
      "title": "Migrate get_factions to Rust",
      "priority": 12,
      "description": "politics.py has 9 regex calls for faction extraction. Migrate to Rust for accurate faction happiness and ethics.",
      "files": ["stellaris_save_extractor/politics.py"],
      "passes": false,
      "criteria": [
        "RUN: grep -c 're\\.search\\|re\\.findall\\|re\\.finditer' stellaris_save_extractor/politics.py | awk '{if ($1 < 5) exit 0; else exit 1}' (regex count reduced by >45%)",
        "RUN: grep -q 'iter_section\\|extract_sections' stellaris_save_extractor/politics.py (uses Rust session ops)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); r=e.get_factions(); ctx.__exit__(None,None,None); print(f'Factions: {type(r)}'); assert isinstance(r, dict)\" (works with session)"
      ],
      "notes": "Faction data affects advisor personality and recommendations. Ethics attraction values need accurate extraction."
    },
    {
      "id": "MIG-034",
      "title": "Migrate get_leviathans to Rust",
      "priority": 12,
      "description": "leviathans.py has 6 regex calls for space creatures and guardians. Migrate to Rust for complete leviathan state.",
      "files": ["stellaris_save_extractor/leviathans.py"],
      "passes": false,
      "criteria": [
        "RUN: grep -c 're\\.search\\|re\\.findall\\|re\\.finditer' stellaris_save_extractor/leviathans.py | awk '{if ($1 < 3) exit 0; else exit 1}' (regex count reduced by >50%)",
        "RUN: grep -q 'iter_section\\|extract_sections' stellaris_save_extractor/leviathans.py (uses Rust session ops)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); r=e.get_leviathans() if hasattr(e, 'get_leviathans') else {}; ctx.__exit__(None,None,None); print('OK')\" (works with session)"
      ],
      "notes": "Leviathans, guardians, space creatures. Small file but completes full extraction coverage."
    },
    {
      "id": "MIG-040",
      "title": "Remove regex fallbacks from economy.py (ESCAPE HATCH)",
      "priority": 20,
      "description": "ESCAPE HATCH: First fallback removal. If this fails, add pattern and STOP further removals. Delete _regex methods, update dispatch to call Rust directly.",
      "files": ["stellaris_save_extractor/economy.py"],
      "passes": false,
      "criteria": [
        "RUN: ! grep -q 'def _get_resources_regex' stellaris_save_extractor/economy.py (regex method removed)",
        "RUN: grep -q 'def get_resources' stellaris_save_extractor/economy.py (main method exists)",
        "RUN: python3 -c \"from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); from save_extractor import SaveExtractor; e=SaveExtractor('test_save.sav'); r=e.get_resources(); ctx.__exit__(None,None,None); assert 'stockpiles' in r or 'current' in r, 'FAILED'; print('ESCAPE HATCH PASSED')\" (works without fallback)"
      ],
      "notes": "ESCAPE HATCH: If criterion 3 fails, add pattern 'Fallback removal failed: [reason]' and STOP. Do NOT proceed with MIG-041+."
    },
    {
      "id": "MIG-041",
      "title": "Remove regex fallbacks from planets.py",
      "priority": 21,
      "description": "Delete _get_planets_regex, _get_population_by_planet_regex. Update dispatch to call Rust directly.",
      "files": ["stellaris_save_extractor/planets.py"],
      "passes": false,
      "criteria": [
        "RUN: ! grep -q 'def _get_planets_regex' stellaris_save_extractor/planets.py (removed)",
        "RUN: python3 -c \"from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); from save_extractor import SaveExtractor; e=SaveExtractor('test_save.sav'); r=e.get_planets(); ctx.__exit__(None,None,None); print('OK')\" (works)"
      ],
      "notes": "Only proceed if MIG-040 passed."
    },
    {
      "id": "MIG-042",
      "title": "Remove regex fallbacks from player.py",
      "priority": 21,
      "description": "Delete all _regex methods from player.py.",
      "files": ["stellaris_save_extractor/player.py"],
      "passes": false,
      "criteria": [
        "RUN: ! grep -q '_regex' stellaris_save_extractor/player.py (removed)",
        "RUN: python3 -c \"from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); from save_extractor import SaveExtractor; e=SaveExtractor('test_save.sav'); r=e.get_player_status(); ctx.__exit__(None,None,None); print('OK')\" (works)"
      ],
      "notes": "Only proceed if MIG-040 passed."
    },
    {
      "id": "MIG-043",
      "title": "Remove regex fallbacks from diplomacy.py",
      "priority": 21,
      "description": "Delete all _regex methods from diplomacy.py.",
      "files": ["stellaris_save_extractor/diplomacy.py"],
      "passes": false,
      "criteria": [
        "RUN: ! grep -q 'def _get.*_regex' stellaris_save_extractor/diplomacy.py (removed)",
        "RUN: python3 -c \"from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); from save_extractor import SaveExtractor; e=SaveExtractor('test_save.sav'); r=e.get_diplomacy(); ctx.__exit__(None,None,None); print('OK')\" (works)"
      ],
      "notes": "Only proceed if MIG-040 passed. Large file."
    },
    {
      "id": "MIG-044",
      "title": "Remove regex fallbacks from military.py",
      "priority": 21,
      "description": "Delete all _regex methods from military.py.",
      "files": ["stellaris_save_extractor/military.py"],
      "passes": false,
      "criteria": [
        "RUN: ! grep -q 'def _get.*_regex' stellaris_save_extractor/military.py (removed)",
        "RUN: python3 -c \"from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); from save_extractor import SaveExtractor; e=SaveExtractor('test_save.sav'); e.get_wars(); e.get_fleets(); ctx.__exit__(None,None,None); print('OK')\" (works)"
      ],
      "notes": "Only proceed if MIG-040 passed."
    },
    {
      "id": "MIG-045",
      "title": "Remove regex fallbacks from technology.py",
      "priority": 21,
      "description": "Delete _get_technology_regex.",
      "files": ["stellaris_save_extractor/technology.py"],
      "passes": false,
      "criteria": [
        "RUN: ! grep -q '_regex' stellaris_save_extractor/technology.py (removed)",
        "RUN: python3 -c \"from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); from save_extractor import SaveExtractor; e=SaveExtractor('test_save.sav'); r=e.get_technology(); ctx.__exit__(None,None,None); print('OK')\" (works)"
      ],
      "notes": "Only proceed if MIG-040 passed."
    },
    {
      "id": "MIG-046",
      "title": "Remove regex fallbacks from base.py",
      "priority": 21,
      "description": "Delete all _regex methods from base.py. Core file.",
      "files": ["stellaris_save_extractor/base.py"],
      "passes": false,
      "criteria": [
        "RUN: ! grep -q 'def _get.*_regex\\|def _analyze.*_regex\\|def _count.*_regex' stellaris_save_extractor/base.py (removed)",
        "RUN: python3 -c \"from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); from save_extractor import SaveExtractor; e=SaveExtractor('test_save.sav'); b=e.get_complete_briefing(); ctx.__exit__(None,None,None); assert 'meta' in b; print('OK')\" (works)"
      ],
      "notes": "Only proceed if MIG-040 passed. Core file - test thoroughly."
    },
    {
      "id": "MIG-047",
      "title": "Remove regex fallbacks from leaders.py",
      "priority": 21,
      "description": "Delete _get_leaders_regex. KEEP species traits regex (P018 - duplicate keys).",
      "files": ["stellaris_save_extractor/leaders.py"],
      "passes": false,
      "criteria": [
        "RUN: ! grep -q 'def _get_leaders_regex' stellaris_save_extractor/leaders.py (main regex removed)",
        "RUN: python3 -c \"from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); from save_extractor import SaveExtractor; e=SaveExtractor('test_save.sav'); r=e.get_leaders(); ctx.__exit__(None,None,None); assert 'leaders' in r; print('OK')\" (works)"
      ],
      "notes": "Only proceed if MIG-040 passed. P018: Keep species traits regex for duplicate keys."
    },
    {
      "id": "MIG-048",
      "title": "Remove RUST_BRIDGE_AVAILABLE checks",
      "priority": 22,
      "description": "Remove all RUST_BRIDGE_AVAILABLE conditionals. Rust is now required.",
      "files": ["stellaris_save_extractor/base.py", "stellaris_save_extractor/economy.py", "stellaris_save_extractor/planets.py"],
      "passes": false,
      "criteria": [
        "RUN: ! grep -q 'RUST_BRIDGE_AVAILABLE' stellaris_save_extractor/*.py (no optional checks)",
        "RUN: grep -q 'from rust_bridge import' stellaris_save_extractor/base.py (direct import)"
      ],
      "notes": "Final cleanup. Rust is now a hard requirement."
    },
    {
      "id": "MIG-049",
      "title": "Update README for Rust requirement",
      "priority": 23,
      "description": "Document that Rust build is required.",
      "files": ["README.md"],
      "passes": false,
      "criteria": [
        "RUN: grep -q 'cargo build' README.md (build instructions)",
        "RUN: grep -qi 'rust.*require' README.md (requirement documented)"
      ],
      "notes": "Final documentation."
    }
  ],
  "discovered": []
}
