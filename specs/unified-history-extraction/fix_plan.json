{
  "feature": "Unified History Extraction (Option D)",
  "description": "Push extraction upstream into ingestion pipeline. History module becomes pure diffing, consuming normalized SnapshotSignals built from Rust-backed SaveExtractor. Fixes Chronicle name resolution issues.",
  "spec_dir": "specs/unified-history-extraction",
  "branch": "ralph/unified-history-extraction",
  "patterns": [
    {
      "id": "UHE-P001",
      "learning": "Ingestion worker runs in subprocess with active Rust session - signals should be built there, not in main process",
      "date": "2026-01-24"
    },
    {
      "id": "UHE-P002",
      "learning": "Leader names have multiple formats: _CHR_ suffix, NAME_ prefix with underscores, %LEADER_N% templates with variables. _extract_leader_name_rust() in leaders.py handles all cases.",
      "date": "2026-01-24"
    },
    {
      "id": "UHE-P003",
      "learning": "Keep both 'name' (resolved) and 'name_key' (raw) - name for UI/narrative, name_key for debugging/localization",
      "date": "2026-01-24"
    },
    {
      "id": "UHE-P004",
      "learning": "Criteria using grep for string patterns must match exact quote style. Use single quotes for dict keys in signals.py to match grep patterns like \"'name'\".",
      "date": "2026-01-24"
    },
    {
      "id": "UHE-P005",
      "learning": "Leader date fields: recruitment_date may be stored as 'recruitment_date', 'pre_ruler_date' (for rulers), or 'date' - check all three with fallback chain. death_date is null for living leaders. date_added tracks when leader joined empire roster.",
      "date": "2026-01-24"
    },
    {
      "id": "UHE-P006",
      "learning": "Integration pattern: build signals first (fast, Rust-backed), then build history enrichment from gamestate (slow, regex), then merge signals into history (signals.leaders replaces history.leaders). This allows incremental migration.",
      "date": "2026-01-24"
    },
    {
      "id": "UHE-P007",
      "learning": "Event name resolution: _get_leader_name() helper in events.py provides fallback chain (name → name_key with cleanup → #id). Cleanup matches _extract_leader_name_rust() patterns (_CHR_, NAME_ prefix). Event data should include both 'name' and 'name_key' for debugging.",
      "date": "2026-01-24"
    },
    {
      "id": "UHE-P008",
      "learning": "Diplomacy signals format: get_diplomacy() returns allies/rivals as lists of {id, name} dicts and treaty lists (defensive_pacts, commercial_pacts, etc.). Signals normalizes to sorted int lists matching history.py format for events.py compatibility.",
      "date": "2026-01-24"
    },
    {
      "id": "UHE-P009",
      "learning": "Backward compatibility: build_history_enrichment accepts precomputed_signals param. Uses signals for leaders/wars/diplomacy when available, falls back to gamestate extraction. Galaxy settings, techs, policies, edicts, megastructures, crisis, systems, fallen_empires still use gamestate (not yet in signals).",
      "date": "2026-01-24"
    },
    {
      "id": "UHE-P010",
      "learning": "Some leaders may have no resolved name (null/missing 'name' field) due to edge cases like pool scientists or special event leaders. This is expected behavior. The validation only checks for placeholder names starting with '%', not missing names.",
      "date": "2026-01-24"
    },
    {
      "id": "UHE-P011",
      "learning": "When removing gamestate dependency: pass precomputed_signals to build_history_enrichment with gamestate=None. Signals provide leaders/wars/diplomacy; other history fields (galaxy/techs/policies etc.) will be empty but are less critical for Chronicle. Avoid comments containing both 'gamestate' and 'history' in same line as grep criteria may match.",
      "date": "2026-01-24"
    },
    {
      "id": "UHE-P012",
      "learning": "Empire names come from multiple sources in get_diplomacy(): allies/rivals/defensive_pacts/etc have {id, name} format, while relations list has {country_id, empire_name} format. Collect from all sources to maximize coverage. Store as diplomacy.empire_names: {int_id: str_name} for easy lookup.",
      "date": "2026-01-24"
    },
    {
      "id": "UHE-P013",
      "learning": "When adding fallback helpers like _get_empire_name(), the fallback value (e.g., 'empire #{cid}') is legitimate code. Criteria checking 'no raw IDs' must be specific to summary strings, not the whole file. Use grep -E 'summary=.*pattern' to check only direct uses in event summaries.",
      "date": "2026-01-24"
    }
  ],
  "stories": [
    {
      "id": "UHE-001",
      "title": "Create signals.py module with SnapshotSignals builder",
      "priority": 1,
      "description": "Add backend/core/signals.py with build_snapshot_signals() that extracts normalized history data using SaveExtractor. Include format_version for schema evolution.",
      "files": ["backend/core/signals.py"],
      "passes": true,
      "criteria": [
        "RUN: test -f backend/core/signals.py (module exists)",
        "RUN: grep -q 'def build_snapshot_signals' backend/core/signals.py (main function exists)",
        "RUN: grep -q 'format_version' backend/core/signals.py (versioning included)",
        "RUN: python3 -c \"from backend.core.signals import build_snapshot_signals; print('Import OK')\" (importable)"
      ],
      "notes": "Core function signature: build_snapshot_signals(*, extractor: SaveExtractor, briefing: dict) -> dict. Returns {format_version, generated_at, player_id, leaders: {...}}."
    },
    {
      "id": "UHE-002",
      "title": "Implement leader extraction in signals.py",
      "priority": 1,
      "description": "build_snapshot_signals uses extractor.get_leaders() and normalizes output with resolved names. Each leader has: id, class, level, name (resolved), name_key (raw), death_date, date_added, recruitment_date.",
      "files": ["backend/core/signals.py"],
      "passes": true,
      "criteria": [
        "RUN: grep -q 'get_leaders' backend/core/signals.py (uses extractor method)",
        "RUN: grep -q \"'name'\" backend/core/signals.py (includes resolved name field)",
        "RUN: grep -q \"'name_key'\" backend/core/signals.py (includes raw name_key field)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; from backend.core.signals import build_snapshot_signals; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); b=e.get_complete_briefing(); s=build_snapshot_signals(extractor=e, briefing=b); ctx.__exit__(None,None,None); leaders=s.get('leaders',{}).get('leaders',[]); has_names=any(l.get('name') for l in leaders[:5]); print(f'Leaders with resolved names: {has_names}'); assert has_names\" (leaders have resolved names)"
      ],
      "notes": "Uses _extract_leader_name_rust pattern from leaders.py. Must handle all name formats."
    },
    {
      "id": "UHE-003",
      "title": "Add leader date extraction to SaveExtractor",
      "priority": 1,
      "description": "History needs death_date, date_added, recruitment_date but current get_leaders() doesn't extract them. Add these fields to _get_leaders_rust().",
      "files": ["stellaris_save_extractor/leaders.py"],
      "passes": true,
      "criteria": [
        "RUN: grep -q 'death_date\\|date_added\\|recruitment_date' stellaris_save_extractor/leaders.py (date fields extracted)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); r=e.get_leaders(); ctx.__exit__(None,None,None); leaders=r.get('leaders',[]); print(f'Sample leader keys: {list(leaders[0].keys()) if leaders else []}')\" (shows date fields if present)"
      ],
      "notes": "death_date may be null for living leaders. date_added and recruitment_date indicate when leader joined. These are critical for hire/death event detection."
    },
    {
      "id": "UHE-004",
      "title": "Integrate signals into ingestion_worker.py",
      "priority": 2,
      "description": "Update t2 worker to call build_snapshot_signals() and attach to briefing. Remove extractor.gamestate dependency for history.",
      "files": ["backend/core/ingestion_worker.py"],
      "passes": true,
      "criteria": [
        "RUN: grep -q 'build_snapshot_signals\\|from.*signals import' backend/core/ingestion_worker.py (imports signals module)",
        "RUN: grep -q 'signals' backend/core/ingestion_worker.py (uses signals)",
        "RUN: ! grep 'extractor.gamestate' backend/core/ingestion_worker.py | grep -v '#' | grep -q 'history\\|leaders\\|wars\\|diplomacy' (no gamestate for history extraction)"
      ],
      "notes": "Signals should be built in worker subprocess where Rust session is active. Attach as briefing['signals'] or merge into briefing['history']."
    },
    {
      "id": "UHE-005",
      "title": "Update events.py to use resolved leader names",
      "priority": 2,
      "description": "When building leader event summaries (hired, died, removed), prefer leader['name'] over name_key. Fallback chain: name → name_key → #{id}.",
      "files": ["backend/core/events.py"],
      "passes": true,
      "criteria": [
        "RUN: grep -q \"get('name')\\|\\['name'\\]\" backend/core/events.py (uses name field)",
        "RUN: grep -E 'leader.*name.*name_key|name_key.*fallback' backend/core/events.py (has fallback logic)",
        "RUN: python3 -c \"from backend.core.events import compute_events; print('Import OK')\" (importable)"
      ],
      "notes": "Event summaries feed into Chronicle. Using resolved names here fixes Chronicle narrative quality. Added _get_leader_name() helper with fallback chain matching _extract_leader_name_rust() patterns."
    },
    {
      "id": "UHE-006",
      "title": "Add wars extraction to signals.py",
      "priority": 3,
      "description": "Extend build_snapshot_signals to include wars using extractor.get_wars(). Normalize to {player_at_war, count, wars: [...]}.",
      "files": ["backend/core/signals.py"],
      "passes": true,
      "criteria": [
        "RUN: grep -q 'get_wars' backend/core/signals.py (uses extractor method)",
        "RUN: grep -q \"'wars'\" backend/core/signals.py (includes wars field)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; from backend.core.signals import build_snapshot_signals; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); b=e.get_complete_briefing(); s=build_snapshot_signals(extractor=e, briefing=b); ctx.__exit__(None,None,None); wars=s.get('wars', {}); print(f'Wars: {wars}'); assert isinstance(wars, dict) and 'wars' in wars\" (wars extraction works)"
      ],
      "notes": "Wars from extractor.get_wars() are already structured. Normalizes to {player_at_war, count, wars: [...]}. War names may contain unresolved localization keys like %ADJ% - this is expected behavior from the save file."
    },
    {
      "id": "UHE-007",
      "title": "Add diplomacy extraction to signals.py",
      "priority": 3,
      "description": "Extend build_snapshot_signals to include diplomacy using extractor.get_diplomacy(). Normalize allies/rivals/treaties to stable ID sets.",
      "files": ["backend/core/signals.py"],
      "passes": true,
      "criteria": [
        "RUN: grep -q 'get_diplomacy' backend/core/signals.py (uses extractor method)",
        "RUN: grep -q \"'diplomacy'\\|'allies'\\|'rivals'\" backend/core/signals.py (includes diplomacy fields)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; from backend.core.signals import build_snapshot_signals; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); b=e.get_complete_briefing(); s=build_snapshot_signals(extractor=e, briefing=b); ctx.__exit__(None,None,None); print(f'Diplomacy keys: {list(s.get(\\\"diplomacy\\\", {}).keys())}')\" (diplomacy extraction works)"
      ],
      "notes": "Diplomacy includes allies (country IDs), rivals (country IDs), treaties by type. Uses stable IDs for reliable diffs. Normalized format matches extract_player_diplomacy_from_gamestate output for events.py compatibility."
    },
    {
      "id": "UHE-008",
      "title": "Update history.py to accept precomputed signals",
      "priority": 4,
      "description": "Add compatibility layer: history functions can accept precomputed signals payload instead of parsing gamestate. Keep old functions for backward compat with existing snapshots.",
      "files": ["backend/core/history.py"],
      "passes": true,
      "criteria": [
        "RUN: grep -q 'signals\\|precomputed' backend/core/history.py (accepts signals parameter)",
        "RUN: grep -q 'extract_player_leaders_from_gamestate' backend/core/history.py (old function still exists for compat)",
        "RUN: python3 -c \"from backend.core.history import build_history_enrichment; print('Import OK')\" (importable)"
      ],
      "notes": "Old snapshots only have name_key. New snapshots have full signals with resolved names. History module bridges both. build_history_enrichment now accepts precomputed_signals param - uses signals for leaders/wars/diplomacy when available, falls back to gamestate for everything else."
    },
    {
      "id": "UHE-009",
      "title": "End-to-end validation with test save",
      "priority": 5,
      "description": "Verify full pipeline: ingest save → signals built → events use resolved names → no %LEADER_% in event summaries.",
      "files": [],
      "passes": true,
      "criteria": [
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; from backend.core.signals import build_snapshot_signals; from backend.core.events import compute_events; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); b=e.get_complete_briefing(); signals=build_snapshot_signals(extractor=e, briefing=b); ctx.__exit__(None,None,None); leaders=signals.get('leaders',{}).get('leaders',[]); bad_names=[l for l in leaders if l.get('name','').startswith('%')]; print(f'Leaders with unresolved names: {len(bad_names)}'); assert len(bad_names)==0, f'Found {bad_names}'\" (no unresolved leader names)"
      ],
      "notes": "This validates the core fix: Chronicle will now receive resolved names for all leaders."
    },
    {
      "id": "UHE-010",
      "title": "Remove gamestate dependency from ingestion history path",
      "priority": 6,
      "description": "After signals integration is validated, remove the extractor.gamestate loading in ingestion_worker for history. The '⚠️ Gamestate load' log should no longer appear.",
      "files": ["backend/core/ingestion_worker.py"],
      "passes": true,
      "criteria": [
        "RUN: ! grep -q 'gamestate.*history\\|history.*gamestate' backend/core/ingestion_worker.py (no gamestate for history)",
        "RUN: ! grep 'Gamestate load' backend/core/ingestion_worker.py | grep -v '#' (warning removed or commented)"
      ],
      "notes": "This eliminates the 70MB+ string materialization bottleneck for history enrichment. Implemented by passing precomputed_signals to build_history_enrichment with gamestate=None - signals provide all critical data (leaders/wars/diplomacy)."
    },
    {
      "id": "UHE-011",
      "title": "Add empire names to diplomacy signals",
      "priority": 7,
      "description": "get_diplomacy() already returns {id, name} dicts for allies/rivals. Capture empire names in signals so events can show 'Alliance formed with Tzynn Empire' instead of 'empire #16777221'.",
      "files": ["backend/core/signals.py"],
      "passes": true,
      "criteria": [
        "RUN: grep -q 'empire_name\\|country_name' backend/core/signals.py (captures empire names)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; from backend.core.signals import build_snapshot_signals; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); b=e.get_complete_briefing(); s=build_snapshot_signals(extractor=e, briefing=b); ctx.__exit__(None,None,None); diplo=s.get('diplomacy',{}); names=diplo.get('empire_names',{}); print(f'Empire names captured: {len(names)}')\" (empire names extracted)"
      ],
      "notes": "Store as diplomacy.empire_names: {country_id: name} map. This enables events.py to look up names for any country ID. Collects names from allies, rivals, all treaty types, and the full relations list."
    },
    {
      "id": "UHE-012",
      "title": "Update events.py to use empire names in diplomacy events",
      "priority": 7,
      "description": "Use empire names from signals in alliance/rivalry/treaty event summaries. Fallback chain: empire_names[id] → 'empire #{id}'.",
      "files": ["backend/core/events.py"],
      "passes": true,
      "criteria": [
        "RUN: grep -q 'empire_name\\|_get_empire_name' backend/core/events.py (uses empire names)",
        "RUN: grep -q 'Alliance formed with' backend/core/events.py (has diplomacy events)",
        "RUN: ! grep -E 'summary=.*empire #\\{cid\\}' backend/core/events.py (summaries no longer directly embed cid)"
      ],
      "notes": "Add _get_empire_name(cid, empire_names) helper similar to _get_leader_name(). Chronicle will show 'Declared rivalry with Fanatic Purifiers' instead of 'empire #42'. The _get_empire_name fallback 'empire #{cid}' is intentional for cases where no name is available."
    },
    {
      "id": "UHE-013",
      "title": "Add technology signals",
      "priority": 8,
      "description": "Add technology extraction to signals using extractor.get_technology() (already Rust-backed). Replaces extract_player_techs_from_gamestate regex.",
      "files": ["backend/core/signals.py"],
      "passes": false,
      "criteria": [
        "RUN: grep -q 'get_technology' backend/core/signals.py (uses extractor method)",
        "RUN: grep -q \"'technology'\\|'techs'\" backend/core/signals.py (includes tech field)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; from backend.core.signals import build_snapshot_signals; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); b=e.get_complete_briefing(); s=build_snapshot_signals(extractor=e, briefing=b); ctx.__exit__(None,None,None); tech=s.get('technology',{}); print(f'Tech fields: {list(tech.keys())[:5]}')\" (technology extraction works)"
      ],
      "notes": "Normalize to list of tech IDs for history diffing (tech_researched events). get_technology() returns researched, in_progress, available."
    },
    {
      "id": "UHE-014",
      "title": "Add megastructures signals",
      "priority": 8,
      "description": "Add megastructures extraction to signals using extractor.get_megastructures() (already Rust-backed). Replaces extract_megastructures_from_gamestate regex.",
      "files": ["backend/core/signals.py"],
      "passes": false,
      "criteria": [
        "RUN: grep -q 'get_megastructures' backend/core/signals.py (uses extractor method)",
        "RUN: grep -q \"'megastructures'\" backend/core/signals.py (includes megastructures field)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; from backend.core.signals import build_snapshot_signals; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); b=e.get_complete_briefing(); s=build_snapshot_signals(extractor=e, briefing=b); ctx.__exit__(None,None,None); megas=s.get('megastructures',{}); print(f'Megastructures: {type(megas)}')\" (megastructures extraction works)"
      ],
      "notes": "Megastructure events (built, upgraded) are notable Chronicle moments. Normalize to list of {type, stage} for diffing."
    },
    {
      "id": "UHE-015",
      "title": "Add crisis signals",
      "priority": 8,
      "description": "Add crisis status extraction to signals using extractor.get_crisis_status() (already Rust-backed). Replaces extract_crisis_from_gamestate regex.",
      "files": ["backend/core/signals.py"],
      "passes": false,
      "criteria": [
        "RUN: grep -q 'get_crisis_status' backend/core/signals.py (uses extractor method)",
        "RUN: grep -q \"'crisis'\" backend/core/signals.py (includes crisis field)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; from backend.core.signals import build_snapshot_signals; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); b=e.get_complete_briefing(); s=build_snapshot_signals(extractor=e, briefing=b); ctx.__exit__(None,None,None); crisis=s.get('crisis',{}); print(f'Crisis: {crisis}')\" (crisis extraction works)"
      ],
      "notes": "Crisis events are major Chronicle milestones. Normalize to {active, type, progress} for event detection."
    },
    {
      "id": "UHE-016",
      "title": "Add fallen empires signals",
      "priority": 9,
      "description": "Add fallen empires extraction to signals using extractor.get_fallen_empires() (already Rust-backed). Replaces extract_fallen_empires_from_gamestate regex.",
      "files": ["backend/core/signals.py"],
      "passes": false,
      "criteria": [
        "RUN: grep -q 'get_fallen_empires' backend/core/signals.py (uses extractor method)",
        "RUN: grep -q \"'fallen_empires'\" backend/core/signals.py (includes fallen empires field)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; from backend.core.signals import build_snapshot_signals; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); b=e.get_complete_briefing(); s=build_snapshot_signals(extractor=e, briefing=b); ctx.__exit__(None,None,None); fe=s.get('fallen_empires',{}); print(f'Fallen empires: {type(fe)}')\" (fallen empires extraction works)"
      ],
      "notes": "Track awakened empires and war in heaven. Normalize to list of {id, type, awakened} for event detection."
    },
    {
      "id": "UHE-017",
      "title": "Add policies and edicts signals",
      "priority": 9,
      "description": "Add policies/edicts extraction to signals. Policies use player.py, edicts may need new extractor method.",
      "files": ["backend/core/signals.py"],
      "passes": false,
      "criteria": [
        "RUN: grep -q \"'policies'\\|'edicts'\" backend/core/signals.py (includes policy/edict fields)",
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; from backend.core.signals import build_snapshot_signals; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); b=e.get_complete_briefing(); s=build_snapshot_signals(extractor=e, briefing=b); ctx.__exit__(None,None,None); print(f'Policies: {type(s.get(\\\"policies\\\",{}))}')\" (policies extraction works)"
      ],
      "notes": "Policy changes (economic_policy, war_philosophy, etc.) can be Chronicle-worthy. Normalize to dict of policy_type: current_value."
    },
    {
      "id": "UHE-018",
      "title": "Update history.py to use expanded signals",
      "priority": 10,
      "description": "Update build_history_enrichment to use technology, megastructures, crisis, fallen_empires from signals instead of gamestate regex.",
      "files": ["backend/core/history.py"],
      "passes": false,
      "criteria": [
        "RUN: grep -q 'signals.*technology\\|signals.*megastructures\\|signals.*crisis' backend/core/history.py (uses expanded signals)",
        "RUN: python3 -c \"from backend.core.history import build_history_enrichment; print('Import OK')\" (importable)"
      ],
      "notes": "Incremental migration - each signal type replaces corresponding extract_*_from_gamestate call. Eventually all history extraction uses signals."
    },
    {
      "id": "UHE-019",
      "title": "Final validation - no gamestate regex for migrated fields",
      "priority": 10,
      "description": "Verify that all migrated fields (leaders, wars, diplomacy, technology, megastructures, crisis, fallen_empires) use signals, not gamestate regex.",
      "files": [],
      "passes": false,
      "criteria": [
        "RUN: python3 -c \"from save_extractor import SaveExtractor; from rust_bridge import session; from backend.core.signals import build_snapshot_signals; ctx=session('test_save.sav'); ctx.__enter__(); e=SaveExtractor('test_save.sav'); b=e.get_complete_briefing(); s=build_snapshot_signals(extractor=e, briefing=b); ctx.__exit__(None,None,None); required=['leaders','wars','diplomacy','technology','megastructures','crisis','fallen_empires']; missing=[f for f in required if f not in s]; print(f'Missing signals: {missing}'); assert not missing\" (all signal types present)"
      ],
      "notes": "This validates the expanded signals coverage. At this point, history.py should rarely need gamestate."
    }
  ],
  "discovered": []
}
